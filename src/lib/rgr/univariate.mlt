(*
   Copyright 2015:2016
     Leonid Rozenberg <leonidr@gmail.com>

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*)

open Test_utils
open Util

(* Testing the accuracy of numerical algorithms is hard (and fun).
  Linear Regression provides an interesting example.
  There are two parameters that we use to tune the range of data to be
  generated by the tests. They give the user a gauge on the accuracy of
  the algorithms. *)
let () =
  let add_random_test
    ?title ?nb_runs ?nb_tries ?classifier
    ?reducer ?reduce_depth ?reduce_smaller ?random_src gen f spec =
    Test.add_random_test_group "Univariate"
      ?title ?nb_runs ?nb_tries ?classifier
      ?reducer ?reduce_depth ?reduce_smaller ?random_src gen f spec
  in

  (* Short cut evaluation. *)
  let lregress (a, b, pred)  =
    let resp = Array.map (fun x -> b *. x +. a) pred in
    regress ~resp pred
  in

  let simple_test_array =
    Gen.(lift (Array.init 100 float_of_int) "[0.;1.; ... ;99.]")
  in
  let random_test_array b = Gen.(array (make_int 2 50) (bfloat b)) in
  let simple_lrm_inputs b = Gen.(zip3 (bfloat b) (bnon_zero_float b) simple_test_array) in
  let lrm_inputs b      = Gen.(zip3 (bfloat b) (bnon_zero_float b) (random_test_array b)) in
  let lrm_gen b         = Gen.(map1 lregress describe (lrm_inputs b)) in

  (* The tests. *)

  (* Even though this test is awkward, if the [linear_model]' implementation is
     hidden, this guards to against an incorrect implementation. *)
  add_random_test
    ~title:"Lrm models evaluate like linear models"
    Gen.(zip2 (bnon_zero_float 1e8) (lrm_gen 1e8))
    (fun (x, lrm) ->
      let _ = describe lrm in
      eval lrm x)
    Spec.([ always =>
      (fun((x, lrm), y) ->
        equal_floats ~d:dx y (alpha lrm +. beta lrm *. x)) ]);

  add_random_test
    ~title:"Using linear regression on canonical [0.0 ... 99.0] data we can recover coefficients"
    ~nb_runs:1000
    (simple_lrm_inputs 1e8)
    lregress
    Spec.([ always =>
      (fun ((a, b, _), lrm) ->
      (*Printf.printf "1. our lrm %s a %f and b %f\n" (to_string lrm) a b; *)
        (equal_floats ~d:1e-5 a (alpha lrm)) && (equal_floats ~d:1e-5 b (beta lrm)))]);

  add_random_test
    ~title:"Using linear regression on random float data we can recover coefficients"
    ~nb_runs:1000
    (lrm_inputs 1e7)
    lregress
    Spec.([ always =>
      (fun ((a, b, _), lrm) ->
      (*Printf.printf "1. our lrm %s a %f and b %f\n" (to_string lrm) a b; *)
        (equal_floats ~d:1e-1 a (alpha lrm)) && (equal_floats ~d:1e-1 b (beta lrm)))]);

  (* TODO: clever test to react to variance in the predicted variable. *)
  (*
  add_random_test
    ~title:"Confidence intervals are symmetric around evaluation point."
    Gen.(zip3 simple_lrm_gen grt_zer_lss_one bfloat)
    (fun (lrm, alpha_level, x) -> confidence_interval lrm ~alpha_level x)
    Spec.([ always =>
      (fun ((_lrm, _alpha, x), (lb, ub)) ->
        equal_floats ~d:1e-5 x (Util.midpoint lb ub))]);

    ~title:"Prediction intervals grow as alpha increases."
      Gen.(zip3 simple_lrm_gen two_ordered bfloat)
    (fun (lrm, (a1, a2), x) ->
      (*Printf.printf "our lrm %s alpha %f %f and x %f\n" (to_string lrm) a1 a2 x; *)
      prediction_interval lrm ~alpha_level:a1 x,
      prediction_interval lrm ~alpha_level:a2 x)
    Spec.([always =>
      (fun ((_lrm, _alpha_pair, x), ((lb1, ub1), (lb2, ub2))) ->
        ub2 -. lb2 > ub1 -. lb1)])
  *)
  ()
