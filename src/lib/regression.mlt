
open Test_utils

let looe_manually lambda pred resp =
  let predi = Array.to_list pred |> List.mapi (fun i p -> (i, p)) in
  let respi = Array.to_list resp |> List.mapi (fun i r -> (i, r)) in
  let without i =
    List.filter (fun (j, _) -> j <> i) predi |> Array.of_list |> Array.map snd,
    List.filter (fun (j, _) -> j <> i) respi |> Array.of_list |> Array.map snd
  in
  pred
  |> Array.mapi (fun i p ->
    let p_pred, p_resp = without i in
    let model =
      general_linear_regress ~lambda:(`Spec lambda)
        ~pred:p_pred ~resp:p_resp ()
    in
    resp.(i) -. eval_glm model p)


(* Testing the accuracy of numerical algorithms is hard (and fun).
  Linear Regression provides an interesting example.
  There are two parameters that we use to tune the range of data to be
  generated by the tests. They give the user a gage on the accuracy of
  the algorithms.

  *)

module Gen = FGen (struct
  let largest_float = 1e8
end)

let () =
  let module U = Univarite in
  (* handy predicates *)
  let equal_floats x y = not (Util.significantly_different_from x y) in
  let roughly_equal ~order_comp x y =
    let d = (Descriptive.geometric_mean [|x; y|]) /. order_comp in
    not (Util.significantly_different_from ~d x y) in

  let order_comp = 1e5 in (* TODO: rethink this order comparison logic *)
  let roughly_equal = roughly_equal ~order_comp in

  (* Short cut evaluation. *)
  let lregress (a, b, pred)  =
    let resp = Array.map (fun x -> b *. x +. a) pred in
    U.regress None ~resp ~pred ()
  in

  (* useful generators. *)
  (*let grt_zer_lss_one   = Gen.make_float (0.0 +. Util.dx) 1.0 in
  let two_ordered       = Gen.(transform (fun (x,y) -> min x y,max x y)
                                  (zip2 grt_zer_lss_one grt_zer_lss_one))
  in *)
  let simple_test_array =
    Gen.(lift (Array.init 100 float_of_int) "[0.;1.; ... ;99.]")
  in
  let random_test_array = Gen.(array (make_int 2 50) float) in
  let simple_lrm_inputs = Gen.(zip3 float non_zero_float simple_test_array) in
  let lrm_inputs        = Gen.(zip3 float non_zero_float random_test_array) in
  let lrm_gen           = Gen.(map1 lregress U.describe lrm_inputs) in

  (* The tests. *)

  (* Even though this test is awkward, if the [linear_model]' implementation is
     hidden, this guards to against an incorrect implementation. *)
  Test.add_random_test
    ~title:"Regression: lrm models evaluate like linear models"
    Gen.(zip2 non_zero_float lrm_gen)
    (fun (x, lrm) -> U.eval lrm x)
    Spec.([ always =>
      (fun((x, lrm), y) ->
        equal_floats y (U.alpha lrm +. U.beta lrm *. x)) ]);

  Test.add_random_test
    ~title:"Regression: using linear regression on canonical [0.0 ... 99.0] data we can recover coefficients"
    ~nb_runs:1000
    simple_lrm_inputs
    lregress
    Spec.([ always =>
      (fun ((a, b, _), lrm) ->
      (*Printf.printf "1. our lrm %s a %f and b %f\n" (to_string lrm) a b; *)
        (roughly_equal a (U.alpha lrm)) && (roughly_equal b (U.beta lrm)))]);

  Test.add_random_test
    ~title:"Regression: using linear regression on random float data we can recover coefficients"
    ~nb_runs:1000
    lrm_inputs
    lregress
    Spec.([ always =>
      (fun ((a, b, _), lrm) ->
      (*Printf.printf "1. our lrm %s a %f and b %f\n" (to_string lrm) a b; *)
        (roughly_equal a (U.alpha lrm)) && (roughly_equal b (U.beta lrm)))]);

  (* TODO: clever test to react to variance in the predicted variable. *)

(*
  Test.add_random_test
    ~title:"Regression: confidence intervals are symmetric around evaluation point."
    Gen.(zip3 simple_lrm_gen grt_zer_lss_one float)
    (fun (lrm, alpha_level, x) -> confidence_interval lrm ~alpha_level x)
    Spec.([ always =>
      (fun ((_lrm, _alpha, x), (lb, ub)) ->
        roughly_equal x (Util.midpoint lb ub))]);

  Test.add_random_test
    ~title:"Regression: prediction intervals grow as alpha increases."
      Gen.(zip3 simple_lrm_gen two_ordered float)
    (fun (lrm, (a1, a2), x) ->
      (*Printf.printf "our lrm %s alpha %f %f and x %f\n" (to_string lrm) a1 a2 x; *)
      prediction_interval lrm ~alpha_level:a1 x,
      prediction_interval lrm ~alpha_level:a2 x)
    Spec.([always =>
      (fun ((_lrm, _alpha_pair, x), ((lb1, ub1), (lb2, ub2))) ->
        ub2 -. lb2 > ub1 -. lb1)])
*)

  (* This is making a stronger case. *)
  let module Gen = FGen (struct let largest_float = 1e11 end) in
  let max_samples = 10 in
  let max_predictors = 3 in
  Test.add_random_test
    ~title:"Regression: general can recover coefficients."
    Gen.(general_model ~max_samples ~max_predictors)
    (fun (pred, coef, resp) ->
      let glm = general_linear_regress ~resp ~pred () in
      Vectors.equal ~d:1e-2 glm.coefficients coef)
    Spec.([just_postcond_pred is_true]);

  Test.add_random_test
    ~title:"Regression: residuals are just the difference between eval_glm and resp"
    Gen.(general_model ~max_samples ~max_predictors)
    (fun (pred, _, resp) ->
      let glm = general_linear_regress ~resp ~pred () in
      equal_floats glm.residuals.(0) (resp.(0) -. eval_glm glm pred.(0)))
    Spec.([just_postcond_pred is_true]);

  Test.add_random_test
    ~title:"Regression: ridge coefficients are smaller."
    Gen.(general_model ~max_samples ~max_predictors)
    (fun (pred, _, resp) ->
      let glm = general_linear_regress ~resp ~pred () in
      let m = Descriptive.mean resp in
      let lambda = `Spec (m *. m) in    (* has to be big enough *)
      let rdg = general_linear_regress ~lambda ~resp ~pred () in
      let rd = Vectors.dot rdg.coefficients rdg.coefficients in
      let gd = Vectors.dot glm.coefficients glm.coefficients in
      rd < gd)
    Spec.([just_postcond_pred is_true]);

  (*  Computing LOOE has a subtraction of 1/S^2 - 1/lambda so it can be
      very imprecise when numbers get big. *)
  let module Gen = FGen (struct let largest_float = 1e7 end) in
  Test.add_random_test
    ~title:"Svd, Leave-One-Out-Error is same as manually."
    Gen.(general_model ~max_samples:5 ~max_predictors:3
         |> zip2 pos_float)
    (fun (lambda, (pred, _, resp)) ->
      let open Lacaml.D in
      let manually = looe_manually lambda pred resp in
      let svdally  = Vec.to_array (Svd.looe (Svd.svd (Mat.of_array pred)) (Vec.of_array resp) lambda) in
      Vectors.equal ~d:1e9 manually svdally)
    Spec.([just_postcond_pred is_true]);

  ()
