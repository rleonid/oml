
open Test_utils

(* Testing the accuracy of numerical algorithms is hard (and fun).
  Linear Regression provides an interesting example.
  There are two parameters that we use to tune the range of data to be
  generated by the tests. They give the user a gage on the accuracy of
  the algorithms.

  *)

module Gen = FGen (struct
  let largest_float = 1e8
end)

let () =
  (* handy predicates *)
  let equal_floats x y = not (Util.significantly_different_from x y) in
  let roughly_equal ~order_comp x y =
    let d = (Descriptive.geometric_mean [|x; y|]) /. order_comp in
    not (Util.significantly_different_from ~d x y) in

  let order_comp = 1e5 in (* TODO: rethink this order comparison logic *)
  let roughly_equal = roughly_equal ~order_comp in

  (* Short cut evaluation. *)
  let lregress (a, b, pred)  =
    let resp = Array.map (fun x -> b *. x +. a) pred in
    linear_regress ~resp ~pred ()
  in

  (* useful generators. *)
  (*let grt_zer_lss_one   = Gen.make_float (0.0 +. Util.dx) 1.0 in
  let two_ordered       = Gen.(transform (fun (x,y) -> min x y,max x y)
                                  (zip2 grt_zer_lss_one grt_zer_lss_one))
  in *)
  let simple_test_array =
    Gen.(lift (Array.init 100 float_of_int) "[0.;1.; ... ;99.]")
  in
  let random_test_array = Gen.(array (make_int 2 50) float) in
  let simple_lrm_inputs = Gen.(zip3 float non_zero_float simple_test_array) in
  let lrm_inputs        = Gen.(zip3 float non_zero_float random_test_array) in
  (*let simple_lrm_gen    = Gen.(map1 lregress to_string simple_lrm_inputs) in *)
  let lrm_gen           = Gen.(map1 lregress to_string lrm_inputs) in

  (* The tests. *)

  (* Even though this test is awkward, if the [linear_model]' implementation is
     hidden, this guards to against an incorrect implementation. *)
  Test.add_random_test
    ~title:"Regression: lrm models evaluate like linear models"
    Gen.(zip2 non_zero_float lrm_gen)
    (fun (x, lrm) -> eval_lrm lrm x)
    Spec.([ always =>
      (fun((x, lrm), y) ->
        equal_floats y (lrm.alpha +. lrm.beta *. x)) ]);

  Test.add_random_test
    ~title:"Regression: using linear regression on canonical [0.0 ... 99.0] data we can recover coefficients"
    ~nb_runs:1000
    simple_lrm_inputs
    lregress
    Spec.([ always =>
      (fun ((a, b, _), lrm) ->
      (*Printf.printf "1. our lrm %s a %f and b %f\n" (to_string lrm) a b; *)
        (roughly_equal a lrm.alpha) && (roughly_equal b lrm.beta))]);

  Test.add_random_test
    ~title:"Regression: using linear regression on random float data we can recover coefficients"
    ~nb_runs:1000
    lrm_inputs
    lregress
    Spec.([ always =>
      (fun ((a, b, _), lrm) ->
      (*Printf.printf "1. our lrm %s a %f and b %f\n" (to_string lrm) a b; *)
        (roughly_equal a lrm.alpha) && (roughly_equal b lrm.beta))]);

  (* TODO: clever test to react to variance in the predicted variable. *)

(*
  Test.add_random_test
    ~title:"Regression: confidence intervals are symmetric around evaluation point."
    Gen.(zip3 simple_lrm_gen grt_zer_lss_one float)
    (fun (lrm, alpha_level, x) -> confidence_interval lrm ~alpha_level x)
    Spec.([ always =>
      (fun ((_lrm, _alpha, x), (lb, ub)) ->
        roughly_equal x (Util.midpoint lb ub))]);

  Test.add_random_test
    ~title:"Regression: prediction intervals grow as alpha increases."
      Gen.(zip3 simple_lrm_gen two_ordered float)
    (fun (lrm, (a1, a2), x) ->
      (*Printf.printf "our lrm %s alpha %f %f and x %f\n" (to_string lrm) a1 a2 x; *)
      prediction_interval lrm ~alpha_level:a1 x,
      prediction_interval lrm ~alpha_level:a2 x)
    Spec.([always =>
      (fun ((_lrm, _alpha_pair, x), ((lb1, ub1), (lb2, ub2))) ->
        ub2 -. lb2 > ub1 -. lb1)])
*)

  (* This is making a stronger case. *)
  let module Gen = FGen (struct let largest_float = 1e11 end) in
  let largest_number_samples = 10 in
  let largest_number_predictors = 3 in
  let print_float_array m =
    m
    |> Array.map (Kaputt.Utils.make_string_of_array (snd Gen.float))
    |> Array.to_list
    |> String.concat "\n"
  in
  let general_model_array =
    Gen.(zip2
          (make_int 2 largest_number_predictors)
          (make_int 2 largest_number_samples)
         (* +1 is for how we build samples models below. *)
         |> transform (fun (p, s) -> min p s, 1 + max p s)
         |> fun (rcg, _) ->
             (* TODO: refactor this into a bind. *)
             (fun random ->
                let (rows, columns) = rcg random in
                Array.init rows (fun _ ->
                  Array.init columns (fun _ ->
                    (fst Gen.float) random))),
             print_float_array)
  in
  let general_model =
    Gen.(map1 (fun m ->
      let mt = Matrices.transpose m in
      let data = Array.sub mt 1 (Array.length mt - 1) in
      let coef = mt.(0) in
      let resp = Matrices.prod_column_vector data coef in
      let pred = Matrices.transpose data in
      (pred, coef, resp))
      (fun (pred, coef, resp) ->
        Printf.sprintf "predictors: %s\n coefficients: %s\n response: %s\n"
          (print_float_array pred)
          (Kaputt.Utils.make_string_of_array (snd Gen.float) coef)
          (Kaputt.Utils.make_string_of_array (snd Gen.float) resp))
      general_model_array)
  in
  Test.add_random_test
    ~title:"Regression: general can recover coefficients."
    ~nb_runs:1000
    general_model
    (fun (pred, coef, resp) ->
      let glm = sub_general_linear_regress ~resp ~pred () in
      Vectors.equal ~d:1e-2 glm.coefficients coef)
    Spec.([just_postcond_pred is_true]);

  Test.add_random_test
    ~title:"Regression: residuals are just the difference between eval_glm and resp"
    ~nb_runs:1000
    general_model
    (fun (pred, _, resp) ->
      let glm = sub_general_linear_regress ~resp ~pred () in
      let pt = Matrices.transpose pred in
      equal_floats glm.residuals.(0) (resp.(0) -. eval_glm glm pt.(0)))
    Spec.([just_postcond_pred is_true]);

  ()
