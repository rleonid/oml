
open Test_utils

(* Testing the accuracy of numerical algorithms is hard (and fun).
  Linear Regression provides an interesting example.
  There are two parameters that we use to tune the range of data to be
  generated by the tests. They give the user a gage on the accuracy of
  the algorithms.

  *)

module Gen = FGen (struct
  let largest_float = 1e8
end)

let () =
  (* handy predicates *)
  let equal_floats x y = not (Util.significantly_different_from x y) in
  let roughly_equal ~order_comp x y =
    let d = (Descriptive.geometric_mean [|x; y|]) /. order_comp in
    not (Util.significantly_different_from ~d x y) in

  let order_comp = 1e5 in (* TODO: rethink this order comparison logic *)
  let roughly_equal = roughly_equal ~order_comp in

  (* Short cut evaluation. *)
  let lregress (a, b, pred)  =
    let resp = Array.map (fun x -> b *. x +. a) pred in
    linear_regress ~resp ~pred ()
  in

  (* useful generators. *)
  (*let grt_zer_lss_one   = Gen.make_float (0.0 +. Util.dx) 1.0 in
  let two_ordered       = Gen.(transform (fun (x,y) -> min x y,max x y)
                                  (zip2 grt_zer_lss_one grt_zer_lss_one))
  in *)
  let simple_test_array =
    Gen.(lift (Array.init 100 float_of_int) "[0.;1.; ... ;99.]")
  in
  let random_test_array = Gen.(array (make_int 2 50) float) in
  let simple_lrm_inputs = Gen.(zip3 float non_zero_float simple_test_array) in
  let lrm_inputs        = Gen.(zip3 float non_zero_float random_test_array) in
  (*let simple_lrm_gen    = Gen.(map1 lregress to_string simple_lrm_inputs) in *)
  let lrm_gen           = Gen.(map1 lregress to_string lrm_inputs) in

  (* The tests. *)

  (* Even though this test is awkward, if the [linear_model]' implementation is
     hidden, this guards to against an incorrect implementation. *)
  Test.add_random_test
    ~title:"Regression: lrm models evaluate like linear models"
    Gen.(zip2 non_zero_float lrm_gen)
    (fun (x, lrm) -> eval_lrm lrm x)
    Spec.([ always =>
      (fun((x, lrm), y) ->
        equal_floats y (lrm.alpha +. lrm.beta *. x)) ]);

  Test.add_random_test
    ~title:"Regression: using linear regression on canonical [0.0 ... 99.0] data we can recover coefficients"
    ~nb_runs:1000
    simple_lrm_inputs
    lregress
    Spec.([ always =>
      (fun ((a, b, _), lrm) ->
      (*Printf.printf "1. our lrm %s a %f and b %f\n" (to_string lrm) a b; *)
        (roughly_equal a lrm.alpha) && (roughly_equal b lrm.beta))]);

  Test.add_random_test
    ~title:"Regression: using linear regression on random float data we can recover coefficients"
    ~nb_runs:1000
    lrm_inputs
    lregress
    Spec.([ always =>
      (fun ((a, b, _), lrm) ->
      (*Printf.printf "1. our lrm %s a %f and b %f\n" (to_string lrm) a b; *)
        (roughly_equal a lrm.alpha) && (roughly_equal b lrm.beta))]);

  (* TODO: clever test to react to variance in the predicted variable. *)

(*
  Test.add_random_test
    ~title:"Regression: confidence intervals are symmetric around evaluation point."
    Gen.(zip3 simple_lrm_gen grt_zer_lss_one float)
    (fun (lrm, alpha_level, x) -> confidence_interval lrm ~alpha_level x)
    Spec.([ always =>
      (fun ((_lrm, _alpha, x), (lb, ub)) ->
        roughly_equal x (Util.midpoint lb ub))]);

  Test.add_random_test
    ~title:"Regression: prediction intervals grow as alpha increases."
      Gen.(zip3 simple_lrm_gen two_ordered float)
    (fun (lrm, (a1, a2), x) ->
      (*Printf.printf "our lrm %s alpha %f %f and x %f\n" (to_string lrm) a1 a2 x; *)
      prediction_interval lrm ~alpha_level:a1 x,
      prediction_interval lrm ~alpha_level:a2 x)
    Spec.([always =>
      (fun ((_lrm, _alpha_pair, x), ((lb1, ub1), (lb2, ub2))) ->
        ub2 -. lb2 > ub1 -. lb1)])
*)

  let module Gen = FGen (struct let largest_float = 1e2 end) in
  let largest_number_samples = 10 in
  let largest_number_predictors = 3 in
  Test.add_random_test
    ~title:"Regression: general can recover coefficients."
    ~nb_runs:20
    Gen.((matrix (make_int 2 largest_number_predictors)
                (make_int 3 largest_number_samples)
                float))
        (*(zip2 (make_int 2 largest_number_predictors)
              (make_int 2 largest_number_samples))
        |> transform (fun (p, s) -> (p, p + s))
        |> transform (fun (p, s) -> matrix p s float)) *)
    (fun m ->
      let mt = Matrices.transpose m in
      let data = Array.sub mt 1 (Array.length mt - 1) in
      let coef = mt.(0) in
      let resp = Matrices.prod_column_vector data coef in
      let pred = Matrices.transpose data in
      let glm  = sub_general_linear_regress ~resp ~pred () in
      Vectors.equal ~d:100.0 glm.coefficients coef)
    Spec.([just_postcond_pred is_true]);

  ()
